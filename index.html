<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MongoDB High Availability Visualizer</title>
    <link rel="stylesheet" href="main.css">
</head>
<body>

    <h1>MongoDB High Availability Visualizer</h1>

    <div class="controls">
        <span>Choose nodes:</span>
        <button id="btn-3" class="node-btn active">3 nodes</button>
        <button id="btn-5" class="node-btn">5 nodes</button>
        <button id="btn-7" class="node-btn">7 nodes</button>
        <span style="margin-left:2em;">Deployment:</span>
        <button id="single-region-btn" class="region-mode-btn active">Single Region</button>
        <button id="multi-region-btn" class="region-mode-btn">Multi-Region</button>
        <button id="reset-btn" style="margin-left:2em;">Reset</button>
    </div>

    <div id="region-toggles" style="display:none; margin: 1em 0;">
        <span>Regions:</span>
        <button class="region-toggle" data-region="1">Region 1: Available</button>
        <button class="region-toggle" data-region="2">Region 2: Available</button>
        <button class="region-toggle" data-region="3">Region 3: Available</button>
    </div>

    <div id="visualization-container"></div>

    <p id="status-text">Status: Primary Writeable</p>

    <footer>
    <span>Made by David Hiltenbrand (with the help of ✨AI✨)</span>
    <a href="https://www.linkedin.com/in/davidehiltenbrand/" target="_blank" rel="noopener noreferrer" aria-label="LinkedIn Profile">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
            <path d="M20.5 2h-17A1.5 1.5 0 0 0 2 3.5v17A1.5 1.5 0 0 0 3.5 22h17a1.5 1.5 0 0 0 1.5-1.5v-17A1.5 1.5 0 0 0 20.5 2ZM8 19H5V8h3v11ZM6.5 6.73c-.97 0-1.75-.78-1.75-1.75S5.53 3.23 6.5 3.23c.97 0 1.75.78 1.75 1.75S7.47 6.73 6.5 6.73ZM20 19h-3v-5.5c0-1.33-.03-3.04-1.85-3.04-1.85 0-2.13 1.44-2.13 2.94V19h-3V8h2.88v1.32h.04c.4-.76 1.37-1.55 2.84-1.55 3.03 0 3.59 1.99 3.59 4.58V19Z"/>
        </svg>
    </a>
    <a href="https://github.com/DavidHiltenbrand" target="_blank" rel="noopener noreferrer" aria-label="GitHub Profile">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16" fill="currentColor">
            <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27s1.36.09 2 .27c1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.01 8.01 0 0 0 16 8c0-4.42-3.58-8-8-8Z"/>
        </svg>
    </a>
    </footer>

    <script>
        // --- DOM Elements & Constants ---
        const vizContainer = document.getElementById('visualization-container');
        const statusText = document.getElementById('status-text');
        const nodeButtons = document.querySelectorAll('.node-btn');
        const regionModeBtns = document.querySelectorAll('.region-mode-btn');
        const regionToggles = document.getElementById('region-toggles');
        const regionToggleBtns = regionToggles.querySelectorAll('.region-toggle');
        const resetBtn = document.getElementById('reset-btn');

        const COLORS = {
            PRIMARY: 'var(--primary-green)',
            SECONDARY: 'var(--secondary-green)',
            FAILURE: 'var(--failure-red)',
        };

        // --- SVG Templates for Icons ---
        // A red "X" icon for failures
        const failureXSVG = `
            <svg class="failure-x" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <line x1="15" y1="15" x2="85" y2="85" stroke="${COLORS.FAILURE}" stroke-width="8" stroke-linecap="round"/>
                <line x1="85" y1="15" x2="15" y2="85" stroke="${COLORS.FAILURE}" stroke-width="8" stroke-linecap="round"/>
            </svg>
        `;

        // --- Application State ---
        let appState = {
            totalNodes: 0,
            primaryIndex: 0,
            failedIndices: new Set(),
            regionMode: 'single', // 'single' or 'multi'
            nodeRegions: [], // Array of region numbers for each node
            regionStatus: {1: true, 2: true, 3: true}, // true = available, false = outage
        };

        /**
         * Assigns nodes to regions based on node count and multi-region rules.
         * @param {number} numNodes
         * @returns {number[]} Array of region numbers for each node (1-based)
         */
        function assignRegions(numNodes) {
            if (appState.regionMode === 'single') {
                return Array(numNodes).fill(1);
            }
            // Multi-region distribution
            if (numNodes === 3) return [1,2,3];
            if (numNodes === 5) return [1,1,2,2,3];
            if (numNodes === 7) return [1,1,1,2,2,2,3];
            // fallback: single region
            return Array(numNodes).fill(1);
        }

        /**
         * Clears and generates the node visualization in a circle.
         * @param {number} numNodes The number of nodes to create (3, 5, or 7).
         */
        function generateNodes(numNodes) {
            // 1. Reset state and UI
            vizContainer.innerHTML = '';
            appState.totalNodes = numNodes;
            appState.primaryIndex = 0;
            appState.failedIndices = new Set();
            appState.nodeRegions = assignRegions(numNodes);

            // Reset region status if switching to single region
            if (appState.regionMode === 'single') {
                appState.regionStatus = {1: true, 2: true, 3: true};
                regionToggles.style.display = 'none';
            } else {
                regionToggles.style.display = '';
                // Reset region toggles to available
                appState.regionStatus = {1: true, 2: true, 3: true};
                regionToggleBtns.forEach(btn => {
                    btn.textContent = `Region ${btn.dataset.region}: Available`;
                    btn.classList.remove('outage');
                });
            }

            // 2. Define circle layout parameters
            const radius = 150;
            const containerSize = 400;
            const centerX = containerSize / 2;
            const centerY = containerSize / 2;
            // Start angle at -90 degrees (12 o'clock position)
            const angleOffset = -Math.PI / 2;

            // 3. Create and place each node
            for (let i = 0; i < numNodes; i++) {
                const isPrimary = (i === appState.primaryIndex);
                const angle = (i / numNodes) * 2 * Math.PI + angleOffset;
                const x = centerX + radius * Math.cos(angle);
                const y = centerY + radius * Math.sin(angle);

                const nodeEl = document.createElement('div');
                nodeEl.className = 'node';
                nodeEl.style.left = `${x}px`;
                nodeEl.style.top = `${y}px`;
                nodeEl.dataset.id = i;
                nodeEl.dataset.region = appState.nodeRegions[i];

                // Add icons and label
                nodeEl.innerHTML = `
                    <div class="icon-container">
                        <img src="img/mdb-database.png" alt="MongoDB Database Icon" class="db-icon" />
                        ${failureXSVG}
                    </div>
                    <p class="label ${isPrimary ? 'primary' : 'secondary'}">
                        ${isPrimary ? 'Primary' : 'Secondary'}
                    </p>
                    ${appState.regionMode === 'multi' ? `<span class="region-label">Region ${appState.nodeRegions[i]}</span>` : ''}
                `;

                // Add click listener
                nodeEl.addEventListener('click', handleNodeClick);

                vizContainer.appendChild(nodeEl);
            }

            // 4. Update UI elements
            updateButtonStyles(numNodes);
            updateRegionModeStyles();
            updateStatus();
        }

        /**
         * Handles the click event on a node, toggling its failed state.
         * @param {MouseEvent} event The click event.
         */
        function handleNodeClick(event) {
            const nodeEl = event.currentTarget;
            const nodeId = parseInt(nodeEl.dataset.id, 10);

            // If region is in outage, ignore manual toggle
            if (appState.regionMode === 'multi') {
                const region = appState.nodeRegions[nodeId];
                if (!appState.regionStatus[region]) return;
            }

            // Toggle failed state
            if (appState.failedIndices.has(nodeId)) {
                appState.failedIndices.delete(nodeId);
                nodeEl.classList.remove('failed');
            } else {
                appState.failedIndices.add(nodeId);
                nodeEl.classList.add('failed');
            }

            // If the primary node just failed, elect a new one
            if (nodeId === appState.primaryIndex && appState.failedIndices.has(nodeId)) {
                electNewPrimary();
            }

            updateStatus();
        }

        /**
         * Handles region outage toggle.
         */
        function handleRegionToggle(event) {
            const btn = event.currentTarget;
            const region = parseInt(btn.dataset.region, 10);
            const isAvailable = appState.regionStatus[region];

            // Toggle region status
            appState.regionStatus[region] = !isAvailable;

            // Update button UI
            if (appState.regionStatus[region]) {
                btn.textContent = `Region ${region}: Available`;
                btn.classList.remove('outage');
            } else {
                btn.textContent = `Region ${region}: Outage`;
                btn.classList.add('outage');
            }

            // Update all nodes in this region
            for (let i = 0; i < appState.totalNodes; i++) {
                if (appState.nodeRegions[i] === region) {
                    const nodeEl = vizContainer.querySelector(`.node[data-id='${i}']`);
                    if (!appState.regionStatus[region]) {
                        // Outage: mark as failed
                        appState.failedIndices.add(i);
                        nodeEl.classList.add('failed');
                    } else {
                        // Available: unmark as failed (unless user manually failed it)
                        if (nodeEl.classList.contains('failed')) {
                            appState.failedIndices.delete(i);
                            nodeEl.classList.remove('failed');
                        }
                    }
                }
            }

            // If primary is in outage, elect new primary
            if (!appState.regionStatus[appState.nodeRegions[appState.primaryIndex]]) {
                electNewPrimary();
            }

            updateStatus();
        }

        /**
         * Handles region mode toggle (single/multi).
         */
        function handleRegionModeToggle(event) {
            const btn = event.currentTarget;
            const mode = btn.id === 'multi-region-btn' ? 'multi' : 'single';
            if (appState.regionMode !== mode) {
                appState.regionMode = mode;
                generateNodes(appState.totalNodes);
            }
        }

        /**
         * Finds the next available secondary and promotes it to primary.
         */
        function electNewPrimary() {
            // Start searching from the node to the right of the failed primary
            for (let i = 1; i < appState.totalNodes; i++) {
                const potentialNewPrimaryIndex = (appState.primaryIndex + i) % appState.totalNodes;

                // If this node is not failed, promote it
                if (!appState.failedIndices.has(potentialNewPrimaryIndex)) {
                    updatePrimaryNode(potentialNewPrimaryIndex);
                    return; // Exit after successful promotion
                }
            }
            
            // If no nodes are available, set primary to -1 (no primary)
            updatePrimaryNode(-1);
        }
        
        /**
         * Updates the DOM and state to reflect a new primary.
         * @param {number} newPrimaryIndex The index of the new primary node.
         */
        function updatePrimaryNode(newPrimaryIndex) {
            // Demote the old primary if it exists
            if (appState.primaryIndex !== -1) {
                const oldPrimaryNode = vizContainer.querySelector(`.node[data-id='${appState.primaryIndex}']`);
                if(oldPrimaryNode) {
                    const oldLabel = oldPrimaryNode.querySelector('.label');
                    oldLabel.textContent = 'Secondary';
                    oldLabel.classList.remove('primary');
                    oldLabel.classList.add('secondary');
                }
            }

            // Update state
            appState.primaryIndex = newPrimaryIndex;

            // Promote the new primary if one was found
            if (newPrimaryIndex !== -1) {
                 const newPrimaryNode = vizContainer.querySelector(`.node[data-id='${newPrimaryIndex}']`);
                 const newLabel = newPrimaryNode.querySelector('.label');
                 newLabel.textContent = 'Primary';
                 newLabel.classList.remove('secondary');
                 newLabel.classList.add('primary');
            }
        }


        /**
         * Updates the status text based on cluster quorum.
         */
        function updateStatus() {
            const failedCount = appState.failedIndices.size;
            const total = appState.totalNodes;
            const majority = Math.floor(total / 2) + 1;

            if (failedCount === total) {
                statusText.textContent = 'Status: Cluster Offline';
                statusText.style.color = COLORS.FAILURE;
            } else if (failedCount >= majority || appState.primaryIndex === -1) {
                statusText.textContent = 'Status: Read-Only';
                statusText.style.color = COLORS.FAILURE;
            } else {
                statusText.textContent = 'Status: Primary Writeable';
                statusText.style.color = COLORS.PRIMARY;
            }
        }
        
        /**
         * Updates the visual style of the node selection buttons.
         * @param {number} activeCount The number corresponding to the active button.
         */
        function updateButtonStyles(activeCount) {
             nodeButtons.forEach(btn => {
                btn.classList.remove('active');
                if (btn.id === `btn-${activeCount}`) {
                    btn.classList.add('active');
                }
            });
        }

        /**
         * Updates the visual style of the region mode buttons.
         */
        function updateRegionModeStyles() {
            regionModeBtns.forEach(btn => {
                btn.classList.remove('active');
                if (
                    (btn.id === 'single-region-btn' && appState.regionMode === 'single') ||
                    (btn.id === 'multi-region-btn' && appState.regionMode === 'multi')
                ) {
                    btn.classList.add('active');
                }
            });
        }

        /**
         * Resets the app to its original state: 3 nodes, single region, all available.
         */
        function resetApp() {
            appState.regionMode = 'single';
            updateRegionModeStyles();
            generateNodes(3);
        }

        // --- Event Listeners & Initialization ---

        nodeButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                const count = parseInt(e.target.id.split('-')[1], 10);
                generateNodes(count);
            });
        });

        regionModeBtns.forEach(btn => {
            btn.addEventListener('click', handleRegionModeToggle);
        });

        regionToggleBtns.forEach(btn => {
            btn.addEventListener('click', handleRegionToggle);
        });

        resetBtn.addEventListener('click', resetApp);

        // Initial load with 3 nodes
        window.addEventListener('load', () => generateNodes(3));

    </script>
</body>
</html>
